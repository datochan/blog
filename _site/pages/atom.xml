<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>陈大头的博客</title>
 <link href="http://localhost:4000/pages/atom.xml" rel="self" />
 <link href="http://localhost:4000" />
 <updated>2015-11-03T15:49:07+08:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>dato chan</name>
   <email>datochan@qq.com</email>
 </author>

 
 <entry>
   <title>2015-10-25-在xblock-sdk中使用makotemplates</title>
   <link href="http://localhost:4000/2015/10/25/%E5%9C%A8xblock-sdk%E4%B8%AD%E4%BD%BF%E7%94%A8makotemplates.html" />
   <updated>2015-10-25T00:00:00+08:00</updated>
   <id>http://localhost:4000/2015/10/25/在xblock-sdk中使用makotemplates</id>
   <content type="html">&lt;p&gt;在xblock-sdk中编写插件时，代码中没有办法使用中文。初次遇到这个问题时并没有往心里去，自以为代码中用英文等最后通过i18n_tool翻译成中文也就是了。&lt;br /&gt;
今天在一份试卷中插入了两个主观题，由于每个xblock都会将相应的js代码引入到当前页面中，结果可想而知: js代码函数重定义。&lt;br /&gt;
用String.format方式对js代码进行替换关键字无果(js中’{}’是String.format的关键字)，没有办法只能将js代码以字符串的形式写在了python文件中，弄的心里好一顿不舒服，总觉得要是能将mako templates放到xblock中使用就完美了。&lt;br /&gt;
研究了下xblock-sdk的API，发现 pkg-resources 只是简单的读取字符串操作。mako templates只需要render一下就可以将mako模板变成相应的字符串了。所以在xblock中使用mako应该不需要折腾直接用mako代替pkg-resources即可。直接上代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from mako.template import Template

# 载入模板文件
mako_template = Template(filename=os.path.dirname(__file__)+&quot;/static/html/subjective_view.html&quot;)
html_str = mako_template.render_unicode(module_title=module_title,
                                        question= self.question,
                                        module_weight=self.weight,
                                        answer=self.student_answers,
                                        module_id=self.location.block_id)

frag = Fragment(html_str)
# 载入css文件
mako_template = Template(filename=os.path.dirname(__file__)+&quot;/static/css/subjective.css&quot;)
frag.add_css(mako_template.render_unicode())

# 载入js脚本, 传递参数也不仅限于html模板。
mako_template = Template(filename=os.path.dirname(__file__)+&quot;/static/js/src/subjective_student.js&quot;)
frag.add_javascript(mako_template.render_unicode(xblock_id=self.location.block_id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此导入的html、css、js，中文可以随便写，变量也可以随便替换了。如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 这里可以写中文注释
function SubjectiveEditBlock_${xblock_id}(runtime, element){
    // 绑定按钮事件
    $(&quot;#${xblock_id} button:submit&quot;).bind(&#39;click&#39;, function(){
        $(&quot;#${xblock_id} button:submit+p&quot;).css(&quot;display&quot;, &quot;none&quot;);
        var handlerUrl = runtime.handlerUrl(element, &#39;student_submit&#39;);
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后不要忘记在你的模板中加入 &lt;code&gt;## coding: utf-8&lt;/code&gt; , 到这里引入mako就完成了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>xblock-sdk学习笔记之制作studio界面</title>
   <link href="http://localhost:4000/2015/08/28/xblock-sdk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%B6%E4%BD%9Cstudio%E7%95%8C%E9%9D%A2.html" />
   <updated>2015-08-28T00:00:00+08:00</updated>
   <id>http://localhost:4000/2015/08/28/xblock-sdk学习笔记之制作studio界面</id>
   <content type="html">&lt;h3 id=&quot;studio&quot;&gt;使用studio自带的文本编辑器&lt;/h3&gt;

&lt;p&gt;如果我们使用过studio的话不难看出它使用的是tinyMCE。如此问题就好解决了，我们只要定义一个textarea控件，在JS中将其初始化成在线编辑器就可以了，大致代码如下:    &lt;br /&gt;
先给出模板代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- editor --&amp;gt;
&amp;lt;div class=&quot;wrapper-comp-editor is-active is-set&quot; id=&quot;editor-tab&quot; data-editor=&quot;visual&quot;&amp;gt;
    &amp;lt;section class=&quot;html-editor editor&quot;&amp;gt;
        &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Please input the topic request:&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;textarea class=&quot;tiny-mce&quot; name=&quot;editor_question&quot; id=&quot;editor_question&quot;&amp;gt;{question}&amp;lt;/textarea&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相应的JS代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;tinymce.init({
            selector: &quot;#editor-tab .tiny-mce&quot;,
            skin: &#39;studio-tmce4&#39;,
            height:&quot;300&quot;,
            formats: {code: {inline: &#39;code&#39;}
        },
        codemirror: {path: &quot;/static/js/vendor&quot;},
        plugins: &quot;image link codemirror media&quot;,
        menubar: false,
        toolbar_items_size: &#39;small&#39;,
        extended_valid_elements : &quot;iframe[src|frameborder|style|scrolling|class|width|height|name|align|id]&quot;,
        toolbar: &quot;insertfile undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media | code &quot;,
        resize: &quot;both&quot;
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tab&quot;&gt;创建tab选项卡&lt;/h3&gt;

&lt;p&gt;这个功能我想了很久，本来以为很简单，直接在templates中编写一个tabs就可以了。后来发现不行，因为写的两个div都是在&lt;code&gt;&amp;lt;div class=&quot;modal-content&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;中而正常情况下，标签代码应该在&lt;code&gt;&amp;lt;div class=&quot;modal-header&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;中，内容在&lt;code&gt;&amp;lt;div class=&quot;modal-content&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;中。如此才能正好利用上studio中原有的css和js代码。&lt;br /&gt;
最初想的解决方法是在js中动态为相应的div填充内容。后来感觉上这样做不够合理，应该有其它的解决方案，最后分析了 html组件中的文本输入组件才发现只要将设置页面的div增加 metadata_edit 这个class即可实现tab选项卡的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- settings  --&amp;gt;
&amp;lt;div class=&quot;wrapper-comp-settings metadata_edit&quot; id=&quot;settings-tab&quot;&amp;gt;
  &amp;lt;ul class=&quot;list-input settings-list metadata_entry&quot;&amp;gt;
        &amp;lt;li class=&quot;field comp-setting-entry metadata_entry&quot;&amp;gt;
            &amp;lt;div class=&quot;wrapper-comp-setting&quot;&amp;gt;
                &amp;lt;label class=&quot;label setting-label&quot; for=&quot;module_title&quot;&amp;gt;display name&amp;lt;/label&amp;gt;
                &amp;lt;input class=&quot;input setting-input&quot; type=&quot;text&quot; name=&quot;module_title&quot; value=&quot;{module_title}&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;span class=&quot;tip setting-help&quot;&amp;gt;tips: ......&amp;lt;/span&amp;gt;
        &amp;lt;/li&amp;gt;
 
        &amp;lt;li class=&quot;field comp-setting-entry metadata_entry&quot;&amp;gt;
            &amp;lt;div class=&quot;wrapper-comp-setting&quot;&amp;gt;
                &amp;lt;label class=&quot;label setting-label&quot; for=&quot;editor_type&quot;&amp;gt;Editor&amp;lt;/label&amp;gt;
                &amp;lt;select class=&quot;input setting-input&quot; name=&quot;editor_type&quot;&amp;gt;
                            &amp;lt;option value=&quot;visual&quot;&amp;gt;visual&amp;lt;/option&amp;gt;
                            &amp;lt;option value=&quot;org&quot;&amp;gt;org&amp;lt;/option&amp;gt;
                &amp;lt;/select&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;span class=&quot;tip setting-help&quot;&amp;gt;tips: ......&amp;lt;/span&amp;gt;
        &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此，在测试时发现，我们填写的设置选项没有任何效果。在浏览器中调试，js报错为:&lt;code&gt;Failed to load metadata-editor template&lt;/code&gt;。再进一步跟踪就会发现是在&lt;code&gt;/cms/templates/widgets/metadata-edit.html&lt;/code&gt; 模板中加载:&lt;code&gt;/cms/templates/js/metadata-editor.underscore&lt;/code&gt; 文件时加载失败了。其文件代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- js templates --&amp;gt;
&amp;lt;script id=&quot;metadata-editor-tpl&quot; type=&quot;text/template&quot;&amp;gt;
    &amp;lt;%static:include path=&quot;js/metadata-editor.underscore&quot; /&amp;gt;
&amp;lt;/script&amp;gt;  
...

&amp;lt;div class=&quot;wrapper-comp-settings metadata_edit&quot; id=&quot;settings-tab&quot; data-metadata=&#39;${json.dumps(metadata_field_copy, cls=EdxJSONEncoder) | h}&#39;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的 underscore 文件内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;ul class=&quot;list-input settings-list&quot;&amp;gt;
    &amp;lt;% _.each(_.range(numEntries), function() { %&amp;gt;
    &amp;lt;li class=&quot;field comp-setting-entry metadata_entry&quot;&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;% }) %&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此，我们再将我们的template内容改写一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- element --&amp;gt;
&amp;lt;script id=&quot;metadata-editor-tpl&quot; type=&quot;text/template&quot;&amp;gt;
  &amp;lt;ul class=&quot;list-input settings-list metadata_entry&quot;&amp;gt;
        &amp;lt;li class=&quot;field comp-setting-entry metadata_entry&quot;&amp;gt;
            &amp;lt;div class=&quot;wrapper-comp-setting&quot;&amp;gt;
                &amp;lt;label class=&quot;label setting-label&quot; for=&quot;module_title&quot;&amp;gt;display name&amp;lt;/label&amp;gt;
                &amp;lt;input class=&quot;input setting-input&quot; type=&quot;text&quot; name=&quot;module_title&quot; value=&quot;{module_title}&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;span class=&quot;tip setting-help&quot;&amp;gt;tips: ......&amp;lt;/span&amp;gt;
        &amp;lt;/li&amp;gt;

        &amp;lt;li class=&quot;field comp-setting-entry metadata_entry&quot;&amp;gt;
            &amp;lt;div class=&quot;wrapper-comp-setting&quot;&amp;gt;
                &amp;lt;label class=&quot;label setting-label&quot; for=&quot;editor_type&quot;&amp;gt;Editor&amp;lt;/label&amp;gt;
                &amp;lt;select class=&quot;input setting-input&quot; name=&quot;editor_type&quot;&amp;gt;
                            &amp;lt;option value=&quot;visual&quot;&amp;gt;visual&amp;lt;/option&amp;gt;
                            &amp;lt;option value=&quot;org&quot;&amp;gt;org&amp;lt;/option&amp;gt;
                &amp;lt;/select&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;span class=&quot;tip setting-help&quot;&amp;gt;tips: ......&amp;lt;/span&amp;gt;
        &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/script&amp;gt;

&amp;lt;!-- editor --&amp;gt;
&amp;lt;div class=&quot;wrapper-comp-editor is-active is-set&quot; id=&quot;editor-tab&quot; data-editor=&quot;visual&quot;&amp;gt;
    &amp;lt;section class=&quot;html-editor editor&quot;&amp;gt;
        &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Please input the topic request:&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;&amp;lt;textarea class=&quot;tiny-mce&quot; name=&quot;editor_question&quot; id=&quot;editor_question&quot;&amp;gt;{question}&amp;lt;/textarea&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- settings  --&amp;gt;
&amp;lt;div class=&quot;wrapper-comp-settings metadata_edit&quot; id=&quot;settings-tab&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;studio-1&quot;&gt;使用studio自带的保存和取消按钮&lt;/h3&gt;

&lt;p&gt;这个问题在github和googlegroup上有好些人都在问，网上现有的比较通用的处理方法是在&lt;code&gt;&amp;lt;div class=&quot;modal-content&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;中自定义一个保存和取消按钮，在JS中处理(可以参考:&lt;code&gt;https://groups.google.com/forum/#!searchin/edx-code/xblock$20save/edx-code/l246xiaiGAc/TYTrQX0MvPUJ&lt;/code&gt; 和 本文最后的参考资料中的处理方式)。直到后来制作tab页面时才发现自定义的保存、取消按钮会受到选项卡切换的影响。用firebug查看了整个页面的html才知道，页面中原本是有保存和取消按钮的只是被隐藏，不显示而已。&lt;br /&gt;
我最初的解决方法是在js中强行控制 &lt;code&gt;&amp;lt;div class=&quot;modal-actions&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;中的元素，强行令其显示，后来在做选项卡之后发现了新的bug。有js将保存按钮隐藏，将取消按钮的title改成OK了。经过一番折腾调试，发现罪魁祸首是:&lt;code&gt;/static/js/views/modals/edit_xblock.js&lt;/code&gt;，相关代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;onDisplayXBlock: function() {
    var editorView = this.editorView,
        title = this.getTitle();

    // Notify the runtime that the modal has been shown
    editorView.notifyRuntime(&#39;modal-shown&#39;, this);

    // 是否启用自定义的tab控件
    if (editorView.hasCustomTabs()) {
        // Hide the modal&#39;s header as the custom editor provides its own
        this.$(&#39;.modal-header&#39;).hide();

        // Update the custom editor&#39;s title
        editorView.$(&#39;.component-name&#39;).text(title);
    } else {
        this.$(&#39;.modal-window-title&#39;).text(title);
        if (editorView.getDataEditor() &amp;amp;&amp;amp; editorView.getMetadataEditor()) {
            this.addDefaultModes();
            this.selectMode(editorView.mode);
        }
    }

    // 是否使用自定义的动作按钮
    if (!editorView.hasCustomButtons()) {
        // 如果当前的xblock插件不支持保存功能，就禁用保存按钮。
        if (!editorView.xblock.save) {
            this.disableSave();
        }
        this.getActionBar().show();
    }

    // Resize the modal to fit the window
    this.resize();
},

// 禁用保存按钮
disableSave: function() {
    var saveButton = this.getActionButton(&#39;save&#39;),
        cancelButton = this.getActionButton(&#39;cancel&#39;);
    saveButton.hide();
    cancelButton.text(gettext(&#39;OK&#39;));
    cancelButton.addClass(&#39;action-primary&#39;);
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这代码的意思很明显是说，该xblock插件不支持save方法。根据栈回朔，定位到相关代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;    handleXBlockFragment: function(fragment, options) {
        var self = this,
            wrapper = this.$el,
            xblockElement,
            successCallback = options ? options.success || options.done : null,
            errorCallback = options ? options.error || options.done : null,
            xblock,
            fragmentsRendered;
        
        fragmentsRendered = this.renderXBlockFragment(fragment, wrapper);
        fragmentsRendered.always(function() {
            // 这里得到我们自定义xblock插件的dom对象
            xblockElement = self.$(&#39;.xblock&#39;).first();
            try {
                // 初始化操作，其实就是进去调用我们xblock的js方法，我们可以跟进看一下
                xblock = XBlock.initializeBlock(xblockElement);
                self.xblock = xblock;
                self.xblockReady(xblock);
                if (successCallback) {
                    successCallback(xblock);
                }
            } catch (e) {
                console.error(e.stack);
                // Add &#39;xblock-initialization-failed&#39; class to every xblock
                self.$(&#39;.xblock&#39;).addClass(&#39;xblock-initialization-failed&#39;);
        
                // If the xblock was rendered but failed then still call xblockReady to allow
                // drag-and-drop to be initialized.
                if (xblockElement) {
                    self.xblockReady(null);
                }
                if (errorCallback) {
                    errorCallback();
                }
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 XBlock.initializeBlock 的定义:/common/static/coffee/src/xblock/core.coffee:10&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;initializeBlock: (element, requestToken) -&amp;gt;
    $element = $(element)
    requestToken = requestToken or $element.data(&#39;request-token&#39;)
    children = @initializeBlocks($element, requestToken)
    runtime = $element.data(&quot;runtime-class&quot;)
    version = $element.data(&quot;runtime-version&quot;)
    initFnName = $element.data(&quot;init&quot;)
    $element.prop(&#39;xblock_children&#39;, children)
    if runtime? and version? and initFnName?
        # 根据相应版本获取我们方法的名称
        runtime = new window[runtime][&quot;v#{version}&quot;]
        initFn = window[initFnName]
        # 调用我们自定义的方法,例如我指定的方法名是: frag.initialize_js(&#39;SubjectiveEditBlock&#39;)
        # 此方法是有返回值的，返回一个 类似capa中名后缀为 Descriptor 的xblock对象, 如果没有返回值就是一个空对象。
        block = initFn(runtime, element) ? {}
        block.runtime = runtime
    else
        elementTag = $(&#39;&amp;lt;div&amp;gt;&#39;).append($element.clone()).html();
        console.log(&quot;Block #{elementTag} is missing data-runtime, data-runtime-version or data-init, and can&#39;t be initialized&quot;)
        block = {}

    block.element = element
    block.name = $element.data(&quot;name&quot;)

    $element.trigger(&quot;xblock-initialized&quot;)
    $element.data(&quot;initialized&quot;, true)
    $element.addClass(&quot;xblock-initialized&quot;)
    block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里一切就都很明了了，我们只要让我们自定义的xblock方法返回一个对象，该对象中包含save方法即可，代码大致如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;    // 返回一个自定义对象，其需要有save方法
    function SubjectiveEditDescriptor(){
    }
    
    function SubjectiveEditBlock(runtime, element) {
        // 为返回的对象命名，具体请参考 /common/static/coffee/src/xblock/core.coffee:10
        $(element).data(&#39;name&#39;, &#39;SubjectiveEditDescriptor&#39;);
    
        var subjectiveEditDescriptor = new SubjectiveEditDescriptor();
        
        // 定义save方法
        subjectiveEditDescriptor.save = function(){
            var handlerUrl = runtime.handlerUrl(element, &#39;studio_submit&#39;);
            var data = {
                module_title: $(element).find(&#39;input[name=module_title]&#39;).val(),
                editor_type: $(element).find(&#39;input[name=editor_type]&#39;).val(),
                editor_question: tinyMCE.activeEditor.getContent()
            };
    
            $.post(handlerUrl, JSON.stringify(data)).done(function(response) {
                window.location.reload(false);
            });
        };
    
        tinymce.init({
                    selector: &quot;#editor-tab .tiny-mce&quot;,
                    skin: &#39;studio-tmce4&#39;,
                    height:&quot;300&quot;,
                    formats: {code: {inline: &#39;code&#39;}
                },
                codemirror: {path: &quot;/static/js/vendor&quot;},
                plugins: &quot;image link codemirror media&quot;,
                menubar: false,
                toolbar_items_size: &#39;small&#39;,
                extended_valid_elements : &quot;iframe[src|frameborder|style|scrolling|class|width|height|name|align|id]&quot;,
                toolbar: &quot;insertfile undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media | code &quot;,
                resize: &quot;both&quot;
            });
    
        //  将对象返回
        return subjectiveEditDescriptor;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，Studio界面相关的分析结束。如果哪里有遗漏还望各位看官批评指正。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考资料&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://antoviaque.org/docs/edx/xblock/tutorial.html&quot;&gt;XBlock 0.1 documentation - Tutorial&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://xblock.readthedocs.org/en/latest/&quot;&gt;XBlock: Open edX courseware components&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://idefs.com/development-open-edx-56-xblock-network-video-plug-in-development-infrastructure.html&quot;&gt;[开发] Open edX 56 网 XBlock 视频插件开发(基础)&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#studio&quot; id=&quot;markdown-toc-studio&quot;&gt;使用studio自带的文本编辑器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tab&quot; id=&quot;markdown-toc-tab&quot;&gt;创建tab选项卡&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#studio-1&quot; id=&quot;markdown-toc-studio-1&quot;&gt;使用studio自带的保存和取消按钮&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>python和javascript共用的base64加解密代码</title>
   <link href="http://localhost:4000/2015/08/15/python%E5%92%8Cjavascript%E5%85%B1%E7%94%A8%E7%9A%84base64%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81.html" />
   <updated>2015-08-15T00:00:00+08:00</updated>
   <id>http://localhost:4000/2015/08/15/python和javascript共用的base64加解密代码</id>
   <content type="html">&lt;p&gt;最近在OpenEDX中开发了个新的组件，其中需要支持上传功能。由于全都是异步操作，而一些现有的文件上传的库都失效不可用。所以想自己将文件编码成base64，扔到服务端，服务端接收解码保存，以此来实现文件上传的功能。&lt;br /&gt;
之前在javascript中加解密部分一直喜欢用CryptoJS库。&lt;/p&gt;

&lt;p&gt;结果发现此库对数据Base64编码后，python的base64库解密不出来。后来更换了&lt;a href=&quot;&amp;quot;https://github.com/dankogai/js-base64&amp;quot;&quot;&gt;js-base64&lt;/a&gt; 这个库，还是不行，于是自己用coffeescript写了一个。这里存档，以备后用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;class CSTBase64
    @_keyStr = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#39;
    @encode = (s) -&amp;gt;
        res = []
        leftover = s.length % 3
        end = s.length - leftover
        for i in [0 .. end] by 3
            c2 = s.charCodeAt(i);
            c1 = s.charCodeAt(i+1);
            c0 = s.charCodeAt(i+2);
            res.push(@_keyStr[(c2 &amp;gt;&amp;gt; 2) &amp;amp; 0x3f])
            res.push(@_keyStr[((c2 &amp;amp; 0x3) &amp;lt;&amp;lt; 4) | ((c1 &amp;gt;&amp;gt; 4) &amp;amp; 0x0f)])
            res.push(@_keyStr[((c1 &amp;amp; 0x0f) &amp;lt;&amp;lt; 2) | ((c0 &amp;gt;&amp;gt; 6) &amp;amp; 0x03)])
            res.push(@_keyStr[c0 &amp;amp; 0x3f])

        i += 3
        if leftover == 1
            c2 = s.charCodeAt(i);
            res.push(@_keyStr[(c2 &amp;gt;&amp;gt; 2) &amp;amp; 0x3f])
            res.push(@_keyStr[(c2 &amp;amp; 0x3) &amp;lt;&amp;lt; 4])
            res.push(@_keyStr[-1..])
            res.push(@_keyStr[-1..])

        else if leftover == 2
            c2 = s.charCodeAt(i);
            c1 = s.charCodeAt(i+1);
            res.push(@_keyStr[(c2 &amp;gt;&amp;gt; 2) &amp;amp; 0x3f])
            res.push(@_keyStr[((c2 &amp;amp; 0x3) &amp;lt;&amp;lt; 4) | ((c1 &amp;gt;&amp;gt; 4) &amp;amp; 0x0f)])
            res.push(@_keyStr[(c1 &amp;amp; 0x0f) &amp;lt;&amp;lt; 2])
            res.push(@_keyStr[-1..])

        return res.join(&quot;&quot;)


    @decode = (s)-&amp;gt;
        res = []
        end = len(s)
        if s[-1] == @_keyStr[-1..]
            end -= 4

        for i in [0 .. end] by 4
            c3 = @_keyStr.indexOf(s[i])
            c2 = @_keyStr.indexOf(s[i+1])
            c1 = @_keyStr.indexOf(s[i+2])
            c0 = @_keyStr.indexOf(s[i+3])

            res.push(String.fromCharCode(((c3 &amp;lt;&amp;lt; 2)) | ((c2 &amp;gt;&amp;gt; 4) &amp;amp; 0x03)))
            res.push(String.fromCharCode(((c2 &amp;amp; 0x0f) &amp;lt;&amp;lt; 4) | ((c1 &amp;gt;&amp;gt; 2) &amp;amp; 0x0f)))
            res.push(String.fromCharCode(((c1 &amp;amp; 0x03) &amp;lt;&amp;lt; 6) | (c0 &amp;amp; 0x03f)))

        if end &amp;lt; len(s)
            if s[-2] == @_keyStr[-1..]
                c3 = @_keyStr.indexOf(s[end])
                c2 = @_keyStr.indexOf(s[end+1])
                res.push(String.fromCharCode(((c3 &amp;lt;&amp;lt; 2)) | ((c2 &amp;gt;&amp;gt; 4) &amp;amp; 0x03)))
            else
                c3 = @_keyStr.indexOf(s[end])
                c2 = @_keyStr.indexOf(s[end+1])
                c1 = @_keyStr.indexOf(s[end+2])

                res.push(String.fromCharCode(((c3 &amp;lt;&amp;lt; 2)) | ((c2 &amp;gt;&amp;gt; 4) &amp;amp; 0x03)))
                res.push(String.fromCharCode(((c2 &amp;amp; 0x0f) &amp;lt;&amp;lt; 4) | ((c1 &amp;gt;&amp;gt; 2) &amp;amp; 0x0f)))
        return res.join(&quot;&quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 

</feed>